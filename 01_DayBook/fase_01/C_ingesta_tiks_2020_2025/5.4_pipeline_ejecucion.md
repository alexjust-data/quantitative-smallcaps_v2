**Runbook** claro y ordenado —qué va primero, qué lee qué, qué escribe, y cómo se encadenan— para que no haya duda entre lo que hace `build_dynamic_universe.py` y lo que hace `build_topn_runners.py`.

# Pipeline de ejecución (paso a paso)

## 0) Prerrequisitos (ya completos)

* Tienes **OHLCV 1-min de 20 años** en `raw/polygon/ohlcv_intraday_1m/<ticker>/year=YYYY/month=MM/minute.parquet`.
  Esto es la “malla” sobre la que medimos %chg, RVOL y $volume. 

---

## 1) Generar el **universo dinámico “info-rich”** (por día)

**Qué hace:** a partir de 1-min, agrega a diario por ticker, calcula `%chg_d`, `RVOL(30d)`, `dollar_vol_d`, aplica los umbrales (parametrizables) y **marca `info_rich`**.
**Output:**

* `processed/universe/info_rich/daily/date=YYYY-MM-DD/watchlist.parquet` (uno por día)
* `processed/universe/info_rich/topN_12m.parquet` + `topN_12m.csv` (rolling simple, siempre el último estado) 

**Comando tipo (backfill o EOD):**

```bash
python scripts/fase_C_ingesta_tiks/build_dynamic_universe.py \
  --intraday-root raw/polygon/ohlcv_intraday_1m \
  --outdir processed/universe/info_rich \
  --from 2020-01-01 --to 2025-10-21 \
  --rvol-th 2.0 --pctchg-th 0.15 --dvol-th 5000000 \
  --cap-filter-parquet processed/ref/tickers_dim/tickers_dim.parquet \
  --cap-max 2000000000
```

> Esto produce **watchlists diarias** (la “watchlist computacional”) y mantiene un **TopN_12m global** de apoyo. 

---

## 2) (Opcional, recomendado) Construir **TopN12m “de 5 años” con snapshots**

**Qué hace:** a partir de **todas las watchlists diarias** del paso 1, genera **rankings de runners recurrentes a 12 meses**:

* **Rolling mensual** (un fichero por fin de mes durante 5 años)
* **Cortes anuales** (31-Dic de cada año)
* Índice con los paths

**Output:**

```
processed/universe/info_rich/topn12m/
├─ rolling/month_end/topn_YYYY-MM.parquet
├─ annual/topn_YYYY.parquet
└─ topn12m_index.parquet
```

Cada `topn_*.parquet`: `asof_date, rank, ticker, days_info_rich_win, last_seen`. 

**Comando tipo (5 años, mensual + anual):**

```bash
python scripts/fase_C_ingesta_tiks/build_topn_runners.py \
  --daily-root processed/universe/info_rich/daily \
  --outdir processed/universe/info_rich/topn12m \
  --from 2020-01-01 --to 2025-10-21 \
  --k 200 --snap both
```

> Diferencia clave:
>
> * `build_dynamic_universe.py` **siempre** mantiene **un** `topN_12m.{parquet,csv}` “corriente”.
> * `build_topn_runners.py` crea **una serie histórica de snapshots** (mensuales/anuales) para análisis de régimen, prioridad de ticks históricos, etc. 
>
>
>Qué hace cada uno (y cuándo usarlo)
>
>**`build_dynamic_universe.py` (DIARIO/EOD)**
>
>  * Lee tus 1-min.
>  * Genera la **watchlist del día** (`processed/universe/info_rich/daily/date=YYYY-MM-DD/watchlist.parquet`).
>  * **Mantiene** un **TopN_12m “corriente”** (`processed/universe/info_rich/topN_12m.{parquet,csv}`) que siempre refleja el **último estado** (rolling 12 meses hasta “hoy”).
>  * **Cuándo**: todos los días (EOD o intradía). Es la pieza que alimenta **descarga de ticks** del día.
>
>**`build_topn_runners.py` (PERIÓDICO)**
>
>  * Lee **todas las watchlists diarias** ya generadas por el anterior.
>  * Construye **snapshots históricos** del TopN12m:
>
>    * **mensuales**: `processed/universe/info_rich/topn12m/rolling/month_end/topn_YYYY-MM.parquet`
>    * **anuales**: `processed/universe/info_rich/topn12m/annual/topn_YYYY.parquet`
>    * índice: `…/topn12m_index.parquet`
>  * **Cuándo**: de forma **periódica** (p. ej. fin de mes + fin de año) o cuando quieras estudiar 5 años de régimen.
>  * **Para qué**: priorizar estudios/ticks **históricos** y analizar la **rotación de runners** a lo largo del tiempo.
>
>¿Se excluyen? ¿Pisa uno al otro?
>
>* **No se excluyen.** Pueden convivir sin problema:
>
>  * `build_dynamic_universe.py` escribe **watchlists diarias** y **un único TopN_12m “corriente”** (siempre el más reciente).
>  * `build_topn_runners.py` **no toca** ese archivo “corriente”; escribe **otros** ficheros (snapshots mensuales/anuales) en otra carpeta.
>* **Precaución de carrera**: ejecuta `build_topn_runners.py` **después** de que el diario haya terminado (para que tenga la watchlist del día si quieres incluirla en el snapshot mensual).



---

## 3) Consumir la **watchlist diaria** (y/o los TopN) para el **tick-level**

**Qué hace:** usas la watchlist del **día D** (output del paso 1) para decidir **a quién** bajarle `trades/quotes` ese día.
(Para estudios profundos hacia atrás, usa también los TopN12m de 5 años como priorización.)

* Entrada: `processed/universe/info_rich/daily/date=D/watchlist.parquet`
* Acción: lanzar tu **wrapper de micro-batches** con ese universo temporal.
* Después: construir **DIB/VIB** desde `trades` (o usar 1-min como fallback).

> La justificación y el porqué de este filtrado “info-rich” vienen de tus setups y de la literatura (RVOL, %chg, $-vol), ya lo dejamos documentado. 

---

# Orden recomendado (dos modos)

## A) **Backfill** (reconstruir 5 años con todo el ecosistema)

1. **Paso 1:** `build_dynamic_universe.py` en rango 5y → genera **todas las watchlists diarias** + `topN_12m.csv`. 
2. **Paso 2 (opcional):** `build_topn_runners.py` 5y → produce los **snapshots** (mensuales/anuales) para análisis/selección histórica. 
3. **Paso 3:** para cada día o conjunto de días de interés:

   * leer `…/daily/date=YYYY-MM-DD/watchlist.parquet`;
   * descargar **ticks** de esos tickers;
   * construir **DIB/VIB**;
   * (a partir de aquí) **detectores**, **triple-barrier**, **sample-weights**, **ML**. 

## B) **Operación diaria (EOD/live)**

1. **Paso 1 (día D):** `build_dynamic_universe.py --from D --to D` → genera la **watchlist del día**. 
2. **Paso 3:** con esa watchlist, **descarga ticks** de D → **DIB/VIB** → detectores/labels/ML.
3. **(Mensual/anual)** Ejecuta `build_topn_runners.py` para mantener tus snapshots históricos al día. 

---

# Qué usar cuándo

* **Entradas para ticks hoy:** *watchlist del día D* (paso 1).
* **Priorizar históricos profundos:** *TopN12m snapshots* (paso 2).
* **Si no hay trades de un día:** usa **1-min** como “fallback” para detectores y etiquetas; cuando tengas `trades`, rehaces **DIB/VIB** y re-evalúas. 

Si quieres, te dejo un `makefile`/`ps1` con las tres recetas encadenadas (backfill 5y, EOD D, snapshots mensuales) para que sea un comando por tarea y listo.

---

# Explicación didáctica: Diferencia clara entre ambos scripts

## 🎯 La diferencia principal (analogía del restaurante)

Imagina que tienes un **restaurante**:

1. **`build_dynamic_universe.py`** = El **menú del día** (pizarra)
   - Cada día decides qué platos ofrecer HOY
   - Actualizas la pizarra con "lo más fresco del mercado"
   - Es para **operar hoy**: decides qué stocks vigilar/descargar

2. **`build_topn_runners.py`** = El **archivo histórico** de menús
   - Guarda "qué ofreciste cada mes/año" en un álbum
   - Te permite analizar "qué platos fueron populares en verano 2023 vs invierno 2024"
   - Es para **análisis retrospectivo**: estudiar rotación de runners a lo largo del tiempo

## 📁 ¿Por qué NO se pisan?

Escriben en **lugares diferentes**:

```
processed/universe/info_rich/
├── daily/                          ← build_dynamic_universe.py
│   ├── date=2025-10-22/
│   │   └── watchlist.parquet      (watchlist del día)
│   └── ...
├── topN_12m.parquet                ← build_dynamic_universe.py
├── topN_12m.csv                    (TopN "corriente", siempre el último)
└── topn12m/                        ← build_topn_runners.py
    ├── rolling/month_end/
    │   ├── topn_2025-01.parquet   (snapshot enero 2025)
    │   ├── topn_2025-02.parquet   (snapshot febrero 2025)
    │   └── ...
    ├── annual/
    │   ├── topn_2024.parquet      (snapshot año 2024)
    │   └── topn_2025.parquet
    └── topn12m_index.parquet
```

**Clave**: `topN_12m.parquet` (corriente) ≠ `topn12m/rolling/month_end/topn_*.parquet` (histórico)

## 🔄 Flujo de trabajo típico

### Cada día (trading diario):
```bash
# 1. Generar universo del día
python build_dynamic_universe.py --from today --to today

# 2. Lee: topN_12m.parquet (los 200 runners actuales)
# 3. Decide: "Hoy bajo ticks de ESTOS 200 stocks"
# 4. Descarga ticks solo de esos 200
```

### Fin de mes (análisis histórico):
```bash
# Crear snapshot mensual
python build_topn_runners.py --from 2020-01-01 --to today --snap monthly

# Ahora puedes analizar:
# "¿Qué 200 stocks eran los runners en marzo 2023?"
# "¿Cuántos sobrevivieron como runners hasta hoy?"
```

## 🎓 Casos de uso concretos

### Caso 1: Trading diario
**Solo necesitas** `build_dynamic_universe.py`:
- Te da la watchlist de HOY
- El TopN_12m.parquet corriente
- Bajas ticks de esos stocks

### Caso 2: Análisis histórico de régimen
**Necesitas ambos**:
1. `build_dynamic_universe.py` → genera watchlists diarias (materia prima)
2. `build_topn_runners.py` → lee esas watchlists y crea snapshots mensuales

Luego puedes estudiar:
- "¿Cómo cambió el universo de runners entre bull market 2021 y bear market 2022?"
- "¿Qué sectores dominaban en cada época?"

### Caso 3: Backtest con universo realista
**Necesitas** `build_topn_runners.py`:
- Snapshot mensual te dice "qué stocks habrías visto en enero 2023"
- Evitas look-ahead bias (no usas información del futuro)

## ⚠️ Única precaución: Orden de ejecución

**Si los corres el mismo día**:
```bash
# ✅ CORRECTO
python build_dynamic_universe.py    # primero
python build_topn_runners.py        # después

# ❌ EVITAR (no crítico, pero subóptimo)
python build_topn_runners.py        # lee watchlists hasta ayer
python build_dynamic_universe.py    # genera la de hoy → no incluida en snapshot
```

## 💡 Decisión práctica: ¿Qué activar?

### Modo operativo (trading):
- `build_dynamic_universe.py` → **DIARIO**
- `build_topn_runners.py` → **OPCIONAL** (solo si haces análisis de régimen)

### Modo analista (investigación):
- Ambos scripts
- Snapshots mensuales/anuales son tu mina de oro

---

## Resumen ejecutivo

**Concepto clave**: Uno es para "hoy" (operativo), el otro es para "ayer/hace 5 años" (analítico).

**No se pisan** porque escriben archivos distintos, aunque el segundo LEE lo que genera el primero (las watchlists diarias).

**Pipeline ideal**:
1. **Diario**: `build_dynamic_universe.py` → watchlist del día + TopN corriente
2. **Mensual/anual**: `build_topn_runners.py` → snapshots históricos para análisis de régimen y backtesting sin look-ahead bias
