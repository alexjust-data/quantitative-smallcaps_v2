**Runbook** claro y ordenado â€”quÃ© va primero, quÃ© lee quÃ©, quÃ© escribe, y cÃ³mo se encadenanâ€” para que no haya duda entre lo que hace `build_dynamic_universe.py` y lo que hace `build_topn_runners.py`.

# Pipeline de ejecuciÃ³n (paso a paso)

## 0) Prerrequisitos (ya completos)

* Tienes **OHLCV 1-min de 20 aÃ±os** en `raw/polygon/ohlcv_intraday_1m/<ticker>/year=YYYY/month=MM/minute.parquet`.
  Esto es la â€œmallaâ€ sobre la que medimos %chg, RVOL y $volume. 

---

## 1) Generar el **universo dinÃ¡mico â€œinfo-richâ€** (por dÃ­a)

**QuÃ© hace:** a partir de 1-min, agrega a diario por ticker, calcula `%chg_d`, `RVOL(30d)`, `dollar_vol_d`, aplica los umbrales (parametrizables) y **marca `info_rich`**.
**Output:**

* `processed/universe/info_rich/daily/date=YYYY-MM-DD/watchlist.parquet` (uno por dÃ­a)
* `processed/universe/info_rich/topN_12m.parquet` + `topN_12m.csv` (rolling simple, siempre el Ãºltimo estado) 

**Comando tipo (backfill o EOD):**

```bash
python scripts/fase_C_ingesta_tiks/build_dynamic_universe.py \
  --intraday-root raw/polygon/ohlcv_intraday_1m \
  --outdir processed/universe/info_rich \
  --from 2020-01-01 --to 2025-10-21 \
  --rvol-th 2.0 --pctchg-th 0.15 --dvol-th 5000000 \
  --cap-filter-parquet processed/ref/tickers_dim/tickers_dim.parquet \
  --cap-max 2000000000
```

> Esto produce **watchlists diarias** (la â€œwatchlist computacionalâ€) y mantiene un **TopN_12m global** de apoyo. 

---

## 2) (Opcional, recomendado) Construir **TopN12m â€œde 5 aÃ±osâ€ con snapshots**

**QuÃ© hace:** a partir de **todas las watchlists diarias** del paso 1, genera **rankings de runners recurrentes a 12 meses**:

* **Rolling mensual** (un fichero por fin de mes durante 5 aÃ±os)
* **Cortes anuales** (31-Dic de cada aÃ±o)
* Ãndice con los paths

**Output:**

```
processed/universe/info_rich/topn12m/
â”œâ”€ rolling/month_end/topn_YYYY-MM.parquet
â”œâ”€ annual/topn_YYYY.parquet
â””â”€ topn12m_index.parquet
```

Cada `topn_*.parquet`: `asof_date, rank, ticker, days_info_rich_win, last_seen`. 

**Comando tipo (5 aÃ±os, mensual + anual):**

```bash
python scripts/fase_C_ingesta_tiks/build_topn_runners.py \
  --daily-root processed/universe/info_rich/daily \
  --outdir processed/universe/info_rich/topn12m \
  --from 2020-01-01 --to 2025-10-21 \
  --k 200 --snap both
```

> Diferencia clave:
>
> * `build_dynamic_universe.py` **siempre** mantiene **un** `topN_12m.{parquet,csv}` â€œcorrienteâ€.
> * `build_topn_runners.py` crea **una serie histÃ³rica de snapshots** (mensuales/anuales) para anÃ¡lisis de rÃ©gimen, prioridad de ticks histÃ³ricos, etc. 
>
>
>QuÃ© hace cada uno (y cuÃ¡ndo usarlo)
>
>**`build_dynamic_universe.py` (DIARIO/EOD)**
>
>  * Lee tus 1-min.
>  * Genera la **watchlist del dÃ­a** (`processed/universe/info_rich/daily/date=YYYY-MM-DD/watchlist.parquet`).
>  * **Mantiene** un **TopN_12m â€œcorrienteâ€** (`processed/universe/info_rich/topN_12m.{parquet,csv}`) que siempre refleja el **Ãºltimo estado** (rolling 12 meses hasta â€œhoyâ€).
>  * **CuÃ¡ndo**: todos los dÃ­as (EOD o intradÃ­a). Es la pieza que alimenta **descarga de ticks** del dÃ­a.
>
>**`build_topn_runners.py` (PERIÃ“DICO)**
>
>  * Lee **todas las watchlists diarias** ya generadas por el anterior.
>  * Construye **snapshots histÃ³ricos** del TopN12m:
>
>    * **mensuales**: `processed/universe/info_rich/topn12m/rolling/month_end/topn_YYYY-MM.parquet`
>    * **anuales**: `processed/universe/info_rich/topn12m/annual/topn_YYYY.parquet`
>    * Ã­ndice: `â€¦/topn12m_index.parquet`
>  * **CuÃ¡ndo**: de forma **periÃ³dica** (p. ej. fin de mes + fin de aÃ±o) o cuando quieras estudiar 5 aÃ±os de rÃ©gimen.
>  * **Para quÃ©**: priorizar estudios/ticks **histÃ³ricos** y analizar la **rotaciÃ³n de runners** a lo largo del tiempo.
>
>Â¿Se excluyen? Â¿Pisa uno al otro?
>
>* **No se excluyen.** Pueden convivir sin problema:
>
>  * `build_dynamic_universe.py` escribe **watchlists diarias** y **un Ãºnico TopN_12m â€œcorrienteâ€** (siempre el mÃ¡s reciente).
>  * `build_topn_runners.py` **no toca** ese archivo â€œcorrienteâ€; escribe **otros** ficheros (snapshots mensuales/anuales) en otra carpeta.
>* **PrecauciÃ³n de carrera**: ejecuta `build_topn_runners.py` **despuÃ©s** de que el diario haya terminado (para que tenga la watchlist del dÃ­a si quieres incluirla en el snapshot mensual).



---

## 3) Consumir la **watchlist diaria** (y/o los TopN) para el **tick-level**

**QuÃ© hace:** usas la watchlist del **dÃ­a D** (output del paso 1) para decidir **a quiÃ©n** bajarle `trades/quotes` ese dÃ­a.
(Para estudios profundos hacia atrÃ¡s, usa tambiÃ©n los TopN12m de 5 aÃ±os como priorizaciÃ³n.)

* Entrada: `processed/universe/info_rich/daily/date=D/watchlist.parquet`
* AcciÃ³n: lanzar tu **wrapper de micro-batches** con ese universo temporal.
* DespuÃ©s: construir **DIB/VIB** desde `trades` (o usar 1-min como fallback).

> La justificaciÃ³n y el porquÃ© de este filtrado â€œinfo-richâ€ vienen de tus setups y de la literatura (RVOL, %chg, $-vol), ya lo dejamos documentado. 

---

# Orden recomendado (dos modos)

## A) **Backfill** (reconstruir 5 aÃ±os con todo el ecosistema)

1. **Paso 1:** `build_dynamic_universe.py` en rango 5y â†’ genera **todas las watchlists diarias** + `topN_12m.csv`. 
2. **Paso 2 (opcional):** `build_topn_runners.py` 5y â†’ produce los **snapshots** (mensuales/anuales) para anÃ¡lisis/selecciÃ³n histÃ³rica. 
3. **Paso 3:** para cada dÃ­a o conjunto de dÃ­as de interÃ©s:

   * leer `â€¦/daily/date=YYYY-MM-DD/watchlist.parquet`;
   * descargar **ticks** de esos tickers;
   * construir **DIB/VIB**;
   * (a partir de aquÃ­) **detectores**, **triple-barrier**, **sample-weights**, **ML**. 

## B) **OperaciÃ³n diaria (EOD/live)**

1. **Paso 1 (dÃ­a D):** `build_dynamic_universe.py --from D --to D` â†’ genera la **watchlist del dÃ­a**. 
2. **Paso 3:** con esa watchlist, **descarga ticks** de D â†’ **DIB/VIB** â†’ detectores/labels/ML.
3. **(Mensual/anual)** Ejecuta `build_topn_runners.py` para mantener tus snapshots histÃ³ricos al dÃ­a. 

---

# QuÃ© usar cuÃ¡ndo

* **Entradas para ticks hoy:** *watchlist del dÃ­a D* (paso 1).
* **Priorizar histÃ³ricos profundos:** *TopN12m snapshots* (paso 2).
* **Si no hay trades de un dÃ­a:** usa **1-min** como â€œfallbackâ€ para detectores y etiquetas; cuando tengas `trades`, rehaces **DIB/VIB** y re-evalÃºas. 

Si quieres, te dejo un `makefile`/`ps1` con las tres recetas encadenadas (backfill 5y, EOD D, snapshots mensuales) para que sea un comando por tarea y listo.

---

# ExplicaciÃ³n didÃ¡ctica: Diferencia clara entre ambos scripts

## ğŸ¯ La diferencia principal (analogÃ­a del restaurante)

Imagina que tienes un **restaurante**:

1. **`build_dynamic_universe.py`** = El **menÃº del dÃ­a** (pizarra)
   - Cada dÃ­a decides quÃ© platos ofrecer HOY
   - Actualizas la pizarra con "lo mÃ¡s fresco del mercado"
   - Es para **operar hoy**: decides quÃ© stocks vigilar/descargar

2. **`build_topn_runners.py`** = El **archivo histÃ³rico** de menÃºs
   - Guarda "quÃ© ofreciste cada mes/aÃ±o" en un Ã¡lbum
   - Te permite analizar "quÃ© platos fueron populares en verano 2023 vs invierno 2024"
   - Es para **anÃ¡lisis retrospectivo**: estudiar rotaciÃ³n de runners a lo largo del tiempo

## ğŸ“ Â¿Por quÃ© NO se pisan?

Escriben en **lugares diferentes**:

```
processed/universe/info_rich/
â”œâ”€â”€ daily/                          â† build_dynamic_universe.py
â”‚   â”œâ”€â”€ date=2025-10-22/
â”‚   â”‚   â””â”€â”€ watchlist.parquet      (watchlist del dÃ­a)
â”‚   â””â”€â”€ ...
â”œâ”€â”€ topN_12m.parquet                â† build_dynamic_universe.py
â”œâ”€â”€ topN_12m.csv                    (TopN "corriente", siempre el Ãºltimo)
â””â”€â”€ topn12m/                        â† build_topn_runners.py
    â”œâ”€â”€ rolling/month_end/
    â”‚   â”œâ”€â”€ topn_2025-01.parquet   (snapshot enero 2025)
    â”‚   â”œâ”€â”€ topn_2025-02.parquet   (snapshot febrero 2025)
    â”‚   â””â”€â”€ ...
    â”œâ”€â”€ annual/
    â”‚   â”œâ”€â”€ topn_2024.parquet      (snapshot aÃ±o 2024)
    â”‚   â””â”€â”€ topn_2025.parquet
    â””â”€â”€ topn12m_index.parquet
```

**Clave**: `topN_12m.parquet` (corriente) â‰  `topn12m/rolling/month_end/topn_*.parquet` (histÃ³rico)

## ğŸ”„ Flujo de trabajo tÃ­pico

### Cada dÃ­a (trading diario):
```bash
# 1. Generar universo del dÃ­a
python build_dynamic_universe.py --from today --to today

# 2. Lee: topN_12m.parquet (los 200 runners actuales)
# 3. Decide: "Hoy bajo ticks de ESTOS 200 stocks"
# 4. Descarga ticks solo de esos 200
```

### Fin de mes (anÃ¡lisis histÃ³rico):
```bash
# Crear snapshot mensual
python build_topn_runners.py --from 2020-01-01 --to today --snap monthly

# Ahora puedes analizar:
# "Â¿QuÃ© 200 stocks eran los runners en marzo 2023?"
# "Â¿CuÃ¡ntos sobrevivieron como runners hasta hoy?"
```

## ğŸ“ Casos de uso concretos

### Caso 1: Trading diario
**Solo necesitas** `build_dynamic_universe.py`:
- Te da la watchlist de HOY
- El TopN_12m.parquet corriente
- Bajas ticks de esos stocks

### Caso 2: AnÃ¡lisis histÃ³rico de rÃ©gimen
**Necesitas ambos**:
1. `build_dynamic_universe.py` â†’ genera watchlists diarias (materia prima)
2. `build_topn_runners.py` â†’ lee esas watchlists y crea snapshots mensuales

Luego puedes estudiar:
- "Â¿CÃ³mo cambiÃ³ el universo de runners entre bull market 2021 y bear market 2022?"
- "Â¿QuÃ© sectores dominaban en cada Ã©poca?"

### Caso 3: Backtest con universo realista
**Necesitas** `build_topn_runners.py`:
- Snapshot mensual te dice "quÃ© stocks habrÃ­as visto en enero 2023"
- Evitas look-ahead bias (no usas informaciÃ³n del futuro)

## âš ï¸ Ãšnica precauciÃ³n: Orden de ejecuciÃ³n

**Si los corres el mismo dÃ­a**:
```bash
# âœ… CORRECTO
python build_dynamic_universe.py    # primero
python build_topn_runners.py        # despuÃ©s

# âŒ EVITAR (no crÃ­tico, pero subÃ³ptimo)
python build_topn_runners.py        # lee watchlists hasta ayer
python build_dynamic_universe.py    # genera la de hoy â†’ no incluida en snapshot
```

## ğŸ’¡ DecisiÃ³n prÃ¡ctica: Â¿QuÃ© activar?

### Modo operativo (trading):
- `build_dynamic_universe.py` â†’ **DIARIO**
- `build_topn_runners.py` â†’ **OPCIONAL** (solo si haces anÃ¡lisis de rÃ©gimen)

### Modo analista (investigaciÃ³n):
- Ambos scripts
- Snapshots mensuales/anuales son tu mina de oro

---

## Resumen ejecutivo

**Concepto clave**: Uno es para "hoy" (operativo), el otro es para "ayer/hace 5 aÃ±os" (analÃ­tico).

**No se pisan** porque escriben archivos distintos, aunque el segundo LEE lo que genera el primero (las watchlists diarias).

**Pipeline ideal**:
1. **Diario**: `build_dynamic_universe.py` â†’ watchlist del dÃ­a + TopN corriente
2. **Mensual/anual**: `build_topn_runners.py` â†’ snapshots histÃ³ricos para anÃ¡lisis de rÃ©gimen y backtesting sin look-ahead bias
