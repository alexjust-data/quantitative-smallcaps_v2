Sí: **opción A** ahora mismo (seguir sin filtro de market cap) es lo correcto para no parar el pipeline. Luego añadimos el cap por fecha en una pasada de enriquecimiento. Te dejo el plan en dos fases:

---

## 1) Continúa sin `market_cap` (ahora)

Lanza el caché **sin** `--cap-filter-parquet`:

```bash
python scripts/fase_C_ingesta_tiks/build_daily_cache.py \
  --intraday-root raw/polygon/ohlcv_intraday_1m \
  --outdir processed/daily_cache \
  --from 2020-01-01 --to 2025-10-21 \
  --parallel 8 --incremental
```

Y el universo dinámico **sin** filtrar por cap (el script ya lo tolera; si la columna es null, salta el filtro):

```bash
python scripts/fase_C_ingesta_tiks/build_dynamic_universe_optimized.py \
  --daily-cache processed/daily_cache \
  --outdir processed/universe/info_rich \
  --from 2025-10-15 --to 2025-10-21 \
  --config configs/universe_config.yaml
```

> Ventaja: validas Opción C (watchlists y TopN_12m) **ya**, sin bloquearte por el cap.

---

## 2) Enriquecer `market_cap` por fecha (después, en una pasada rápida)

Cuando termines la semana de validación, añadimos el cap por fecha con una **dimensión propia** y re-ejecutamos el universo (no hace falta rehacer el caché).

### 2.1 Construir `processed/ref/market_cap_dim.parquet`

Fuente recomendada (lo tienes del Bloque A):

* `raw/polygon/reference/ticker_details/as_of_date=YYYY-MM-DD/details.parquet`
  (trae `market_cap` y, si no, `share_class_shares_outstanding`).

Estrategia:

1. **Consolidar snapshots** de `details.parquet` en una SCD-2:

   * `ticker, effective_from, effective_to, market_cap`
   * si falta `market_cap` pero tienes `shares_outstanding`, la dejaremos null y la calculamos abajo.

2. **Completar** `market_cap` con una estimación diaria cuando falte:

   * `market_cap_d = close_d × shares_outstanding` (si tienes `shares_outstanding` más o menos estable por tramo).
   * Si tampoco hay shares, deja `market_cap_d` a null (el filtro se seguirá saltando para esos casos).

> Si quieres, te paso un `build_market_cap_dim.py` que:
>
> * lee todos los `details.parquet`,
> * genera la SCD-2,
> * y opcionalmente **imputa** cap con `close_d`×`shares` usando tu **daily_cache**.

### 2.2 Join temporal y re-calcular universo

Con la SCD-2 ya creada:

```bash
# (opcional) “inyectar” market_cap_d en el cache SIN re-procesar 1m:
python scripts/fase_C_ingesta_tiks/build_daily_cache.py \
  --intraday-root raw/polygon/ohlcv_intraday_1m \
  --outdir processed/daily_cache \
  --from 2020-01-01 --to 2025-10-21 \
  --parallel 8 --incremental \
  --cap-dim processed/ref/market_cap_dim.parquet   # ← nuevo flag para join temporal
```

O, si prefieres mantener el cache “puro”, simplemente pásale la SCD-2 al universo:

```bash
python scripts/fase_C_ingesta_tiks/build_dynamic_universe_optimized.py \
  --daily-cache processed/daily_cache \
  --outdir processed/universe/info_rich \
  --from 2020-01-01 --to 2025-10-21 \
  --config configs/universe_config.yaml \
  --cap-dim processed/ref/market_cap_dim.parquet    # ← join temporal en lectura
```

> El script hará: `effective_from ≤ trading_day < effective_to`. Si `effective_to` viene nulo, lo trataremos como `2099-12-31` para cubrir el tramo abierto.

---

## ¿Por qué esta secuencia?

* **No te bloqueas**: validas el universo dinámico “info-rich” ya (lo más importante para seguir con ticks, DIB/VIB, etc.).
* **Cap por fecha** es mejor añadirlo **en frío** con una SCD-2 robusta. Además, el filtro de cap es solo **uno** de los criterios (precio, RVOL, %chg, $-vol siguen activos), así que no rompe la lógica de selección ahora.

---

## Señales de que todo va bien

* Se crean `processed/universe/info_rich/daily/date=YYYY-MM-DD/watchlist.parquet`.
* Se actualiza `processed/universe/info_rich/topN_12m.parquet` (corriente).
* Cuando metas la SCD-2 de cap, verás que el **conteo diario** de info-rich bajará **ligeramente** al aplicar `<$2B`; eso es esperado.

¿Lanzo entonces con **Opción A** (sin cap) y te preparo el **`build_market_cap_dim.py`** para que lo ejecutes después?
